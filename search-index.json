[{"content":"卫星实验室，一个专注于研究卫星以及 CRM 的开源组织。\n此项目为卫星实验室主页 xlabs.club 的源码，记录常用文档和零碎博客，欢迎提交 PR 开源共建。\n本地开发 本项目使用 Hugo 开发，使用 Doks 作为主题，本地开发时先安装 Nodejs，然后使用 npm（或 pnpm） 安装 Hugo。\n# 安装 npm 依赖包 npm install # 启动 Web，然后浏览器访问 http://localhost:1313/即可浏览效果 npm run dev # 更多命令请参考 package.json License 本文档采用 CC BY-NC 4.0 许可协议。\n","date":"September 7, 2023","id":0,"permalink":"/docs/guides/introduction/","summary":"卫星实验室，一个专注于研究卫星以及 CRM 的开源组织。\n此项目为卫星实验室主页 xlabs.club 的源码，记录常用文档和零碎博客，欢迎提交 PR 开源共建。\n本地开发 本项目使用 Hugo 开发，使用 Doks 作为主题，本地开发时先安装 Nodejs，然后使用 npm（或 pnpm） 安装 Hugo。\n# 安装 npm 依赖包 npm install # 启动 Web，然后浏览器访问 http://localhost:1313/即可浏览效果 npm run dev # 更多命令请参考 package.","tags":"","title":"Introduction"},{"content":"","date":"September 7, 2023","id":1,"permalink":"/blog/","summary":"","tags":"","title":"Blog"},{"content":"问题描述：\n一个 Java 应用跑在 K8S 容器内，Pod 内只有 Java 这一个进程。应用跑了一段时间后，CPU、内存占用都不高，但是却出现以下 OutOfMemoryError 错误。\nException in thread \u0026#34;slow-fetch-15\u0026#34; java.lang.OutOfMemoryError: unable to create new native thread 428 at java.lang.Thread.start0(Native Method) 429 at java.lang.Thread.start(Thread.java:719) 430 at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:957) 431 at java.util.concurrent.ThreadPoolExecutor.processWorkerExit(ThreadPoolExecutor.java:1025) 432 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167) 433 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 进入 Pod 内，尝试执行任何操作，又会出现 unable to start container process 错误。\n一开始怀疑是内存不足，调大了内存，同时也缩小了 Java 的 xss， 都不起作用。\n真实原因： K8S 容器限制了 PID 数，无法创建新的线程，在 Pod 内 cat /sys/fs/cgroup/pids/pids.max 发现是 1024。\n关于 K8S pid limit， 可参考此资料：https://kubernetes.io/zh-cn/docs/concepts/policy/pid-limiting/.\n但是，PID 为什么会超呢，Pod 内只有一个 Java 进程，PID 数不应该是 1 个吗，这个 PID 限制为什么影响了线程。\n简单来讲，在 Linux 中线程其实是通过轻量级进程实现的，也就是 LWP(light weight process)，因此在 Linux 中每个线程都是一个进程，都拥有一个 PID，换句话说，操作系统原理中的线程，对应的其实是 Linux 中的进程（即 LWP），因此 Linux 内核中的 PID 对应的其实是原理中的 TID。\n在 Pod 内通过 top -p pid -H 查看，可以看到第一列每个线程都分配了一个 PID。\nPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 101 root 20 0 8622220 5.1g 15640 S 0.3 8.1 0:16.29 VM Thread 112 root 20 0 8622220 5.1g 15640 S 0.3 8.1 0:46.13 C2 CompilerThre 113 root 20 0 8622220 5.1g 15640 S 0.3 8.1 0:39.62 C1 CompilerThre 846 root 20 0 8622220 5.1g 15640 S 0.3 8.1 0:00.64 NettyClientSele 850 root 20 0 8622220 5.1g 15640 S 0.3 8.1 0:00.54 NettyClientWork 1 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.27 java 89 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.99 java 90 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:03.29 java 91 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:03.27 java 92 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:03.26 java 93 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:03.30 java 94 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:01.43 java 95 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.11 java 96 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.12 java 97 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.16 java 98 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.31 java 99 root 20 0 8622220 5.1g 15640 S 0.0 8.1 0:00.32 java 为什么要限制 POD PID 数。 按照 K8S 官方说法，进程 ID（PID）是节点上的一种基础资源，很容易就会在尚未超出其它资源约束的时候就已经触及任务个数上限， 进而导致宿主机器不稳定。某日某个不起眼的服务创建了 N 多线程，把整个宿主机打挂了，谁痛谁知道啊。\n","date":"September 7, 2023","id":2,"permalink":"/blog/k8s-pid-limiting-oom/","summary":"问题描述：\n一个 Java 应用跑在 K8S 容器内，Pod 内只有 Java 这一个进程。应用跑了一段时间后，CPU、内存占用都不高，但是却出现以下 OutOfMemoryError 错误。\nException in thread \u0026#34;slow-fetch-15\u0026#34; java.lang.OutOfMemoryError: unable to create new native thread 428 at java.","tags":"k8s","title":"K8S 容器 PID 限制引起的 OOM"},{"content":"从 Spring 到 Spring Boot，迁移升级快速入门以及各种踩坑记录。\n概述 从 Spring 到 Spring Boot，整体开发、运行方式主要变化。\n- 当前（老）模式 新模式（本地） 新模式（线上） 开发习惯 Spring + 外置 Tomcat Spring Boot（embed tomcat） Spring Boot War or Jar Java 版本 8、11、16、17 11、17（推荐）、21 11、17（推荐）、21 Tomcat 版本 8.x、9.x 9.x 9.x（推荐）、10.x 说明：\n理论上支持 Java11，但是要求业务方尽量使用 Java17。其他版本都是实验性质尽量兼容。 线上运行支持 Spring Boot jar 直接运行，但主要业务仍推荐以 war + tomcat 为主。如果希望以 java -jar 方式运行，参考下面的章节“jar 方式运行”描述。 目前 Spring Boot 主要推行版本是 2.7.x。 3.x 版本逐渐适配中。 快速开始 线下支撑系统导航，点击 脚手架 进入 spring start 页面，按自己需求选择模块，生成自己业务模式初始化代码。 写（Copy）业务代码到项目里，修改 pom.xml 根据需要添加新的依赖。 查看本文档中 遇见问题及解决方案 章节，注意如果是老项目迁移，这一步很重要。 本地开发工具启动 main 方法。 上线发布系统，选择 tomcat9:openjdk17 镜像，并勾选 镜像 JDK 版本编译代码。 以上生成的一个最简略的代码结构，更多复杂使用方式参考下方主要 starter 使用说明。\n主要 starter 使用说明 文档会延后，代码不会骗人，更多说明参考各个项目源码的 README，README 会实时更新。\nfxiaoke-spring-cloud-parent 目前有两个公司级父 pom：\n旧：com.fxiaoke.common.fxiaoke-parent-pom 用于原 Spring + Tomcat 方式开发。 新：com.fxiaoke.cloud.fxiaoke-spring-cloud-parent 用于 Spring Boot/Cloud 方式开发。 注意：\nfxiaoke-spring-cloud-parent 导入了 fxiaoke-parent-pom，所以纷享包版本都是一致的，但是三方包比如 spring/netty/okhttp 会随 Spring Boot 版本。 Maven 项目 parent 统一使用公司新 parent pom，这里定义了 Spring Boot、Spring Cloud 以及内部定制的各种 support 和 starter 版本号。\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.fxiaoke.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fxiaoke-spring-cloud-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 注意使用最新版本，可以从脚手架里获取最新版本 --\u0026gt; \u0026lt;version\u0026gt;2.7.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; 主要升级项需关注：\n老项目切换到 Spring Boot 先分析实际生效的 maven dependency，关注下核心包版本是否有大的升级，是否可能对业务造成影响。 Spock and Groovy：Spock 由原来的 1.x 升级到 2.x 版本，同时 Groovy 升级到 4.x 版本，Junit4 升级到 Junit5。 spring-boot-starter-actuator 目前强制依赖 spring-boot-starter-actuator，容器镜像里使用它实现健康检查。 另外强制依赖 spring-boot-starter-web，因为有些基础组件依赖了 ServletContext。\n注意： actuator 的引入会带来一些额外收益，之前我们健康检测只检查服务端口是否有响应，而 actuator 默认还额外检查各个中间件的状态，业务方可根据需要自行增加或删除某些中间件的状态到健康检测服务，具体方式和更多高级应用参考 spring-boot-starter-actuator 官方文档。\ncms-spring-cloud-starter 配置中心 starter，类似 spring-cloud-consul/nacos/config，对接配置中心，实现配置文件动态加载、刷新，代替原 ReloadablePropertySourcesPlaceholderConfigurer。\n使用步骤：\n引入 starter。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fxiaoke.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cms-spring-cloud-starter\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本号建议不写，使用 parent 定义好的版本 --\u0026gt; \u0026lt;/dependency\u0026gt; 增加 src/main/resources/application.properties 文件，内容如下。\n# 当前模块名，必填，必须全局唯一，一般和 maven 子模块保持一致 spring.application.name=cms-starter-sample # 配置导入，这一行必须写。但是配置文件本身是否必须是通过 optional 控制的 spring.config.import=optional:cms:${spring.application.name} 我们使用 spring.config.import 固定格式为 optional:cms:file-name。 optional 表示这个文件可选，配置中心不存在的时候也允许启动，cms 是固定字符代表对接 fs 配置中心。\n在 CMS 配置中心创建需要的配置文件，文件名为 spring-cloud-${spring.application.name}，其中${spring.application.name}替换成真正的文件名，注意当前版本自动追加了前缀spring-cloud-且不允许修改。\n代码中使用几种方式参考 sample 代码，文档查看 spring 官方ConfigurationProperties和 @Value 说明。\n配置变更后，如果想响应变更事件，实现自己逻辑，自定义类中implements ApplicationListener\u0026lt;RefreshScopeRefreshedEvent\u0026gt;\n配置加解密，在配置中心中有个加密功能框（如果看不到可能是没有权限），先使用本 starter 的秘钥加密，使用固定格式 ENC（加密后的内容）配置到文件里，在 java 里 get value 就是已经解密后的了。例如：\nsample.sensitive=ENC(30E239E0958AF3179C7E8EBA3DF618FD) 响应配置更新：\n对于使用使用 ConfigurationProperties 映射的对象类，从对象中每次 get 的值都是刷新后的。推荐这种方式。\n@Data @Configuration @ConfigurationProperties(prefix = \u0026#34;sample\u0026#34;) public class SampleProperties { private String name; } @RefreshScope + @Value 获取 Value 注解的新值。\n@Service @RefreshScope public class ValueService { @Value(\u0026#34;${sample.over.value}\u0026#34;) @Getter private String watchValue; } 监听 RefreshScopeRefreshedEvent 事件。\n@EventListener(RefreshScopeRefreshedEvent.class) public void handlerPropertiesChangeEvent(RefreshScopeRefreshedEvent event) { //此时配置 Bean 已刷新完成，处理自己的业务逻辑 } jar 方式运行 如果不使用外置 Tomcat，使用 java -jar 方式直接运行，首先打包模式为 jar 并在发布时增加环境变量 SPRING_BOOT_JAR_APP=true。\n与外置 Tomcat 模式差别：\njar 模式一个 pod 内只能部署一个模块，不支持多模块合并部署。 jar 模式不会自动把 jar 解压成文件夹（war 模式会），所以关于文件资源的读写要特别注意，参考下面的问题描述章节。 老项目迁移升级步骤 改 pom.xml：修改 parent，引入必须的 starter，删除所有关于 Spring/logback/junit 的依赖项（由 Spring Boot Starter 自动引入），插件切换到 spring-boot-maven-plugin。 原有的 xml 配置，可以改为注解形式，也可以不改直接 @ImportResource 使用。 注意配置扫描范围，原来 xml 中可能是配置是某几个包，Spring Boot 默认扫描 Application.java 所在包，范围可能扩大。 删除原来 web.xml 相关配置，如果有额外的 filter、servlet，需要额外定义 Bean 注入。 Unit Test 更换注解，目前默认 junit 版本是 junit5，原 junit4 注解有较大变更，详细请参考下面的参考资料。 迁移辅助工具 EMT4J\n通过静态扫描指导从 Java 8 升级到 Java 17 需要注意的变更项。\ntomcat-jakartaee-migration\nTomcat 9 到 10 迁移辅助工具。\nspring-boot-migrator\nSpring Boot 迁移工具，通过扫描输出 从 Spring 到 Spring Boot，以及 Spring Boot 3 迁移指导意见。\nWar 配置转移 If you try to migrate a Java legacy application to Spring Boot you will find out that Spring Boot ignores the web.xml file when it is run as embedded container.\nwebapp web.xml 配置如何转移到 spring boot war 形式。 参考：https://www.baeldung.com/spring-boot-dispatcherservlet-web-xml\n遇见问题及解决方案 下面记录一些比较常见的问题，更多问题请参考下面章节中的参考资料，里面的问题很有参考价值。\ncom.google.common.io.Resources#getResource 无法获取到 jar 包内资源\n如果是 java -jar 模式运行， Thread.currentThread().getContextClassLoader().getResource(resourceName) 形式的调用都无法获取 jar 包内资源，可考虑使用 InputStream resourceFile = getClass().getResourceAsStream(resourceName); 方式代替。\nPostConstruct 和 PreDestroy 注解不生效\n参考链接 https://stackoverflow.com/questions/18161682/why-is-postconstruct-not-called 先逐个排除。\n我所遇到的原因：PostConstruct、PreDestroy 等注解可能存在多个实现或者过个版本，比如以下 jar 包都可能包含：\njavax.annotation-api-1.3.2.jar jakarta.annotation-api-1.3.5.jar jboss-annotations-api_1.3_spec-2.0.1.Final.jar 解决方法：排除依赖，只保留 jakarta.annotation-api 一种，且只能有一个版本。\nkafka 使用报错，日志类似如下：\nERROR c.f.s.SenderManager cannot send, org.apache.kafka.common.KafkaException: org.apache.kafka.clients.producer.internals.DefaultPartitioner is not an instance of org.apache.kafka.clients.producer.Partitioner 原因：因为 classpath 下包含多个不同版本的 kafka-client.jar，检查依赖项，确保只引用一个版本。\n告警：SLF4J: Class path contains multiple SLF4J bindings.\n多个 jar 包含 SLF4J 实现，或引入了多个 logback 版本，请根据提示排除不需要的 jar 包。\nXML 中使用 AOP 注解，运行期报错如下（建议用到 AOP 的提前检查，因为运行期才会报错）：JoinPointMatch ClassNotFoundException\nCaused by: java.lang.ClassNotFoundException: org.aspectj.weaver.tools.JoinPointMatch at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1412) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1220) ... 58 more 依赖 spring aop，请确认是否引入 spring-boot-starter-aop。\n本地使用 Java 17 启动，类似如下报错。\nERROR o.s.b.SpringApplication Application run failed java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not \u0026#34;opens java.lang\u0026#34; to unnamed module @443118b0 at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) at com.alibaba.dubbo.common.compiler.support.JavassistCompiler.doCompile(JavassistCompiler.java:123) [6 skipped] at com.alibaba.dubbo.common.compiler.support.AbstractCompiler.compile(AbstractCompiler.java:59) at com.alibaba.dubbo.common.compiler.support.AdaptiveCompiler.compile(AdaptiveCompiler.java:46) 本地命令行中启动参数里主动追加以下参数（这些参数在发布系统的镜像里默认已经加了），IDEA 启动时设置到VM options里：\n--add-opens=java.base/java.lang.reflect=ALL-UNNAMED --add-opens=java.base/java.math=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED Bean 重复定义错误，报错信息类似如下。\nThe bean \u0026#39;eieaConverterImpl\u0026#39;, defined in class path resource [spring/ei-ea-converter.xml], could not be registered. A bean with that name has already been defined in class path resource [spring/ei-ea-converter.xml] and overriding is disabled. Action: Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true 可能因为注解扫描范围增广或者有同样包多版本引入，导致扫描到多个。确认多处定义是否一致，如果不一致查看原项目哪个生效，以生效为准。如果一致，找到定义的地方查看是否能整个文件排除掉，实在不能在 application.properties 中设置 spring.main.allow-bean-definition-overriding=true 可解决。\n如下报错 class xxx is not visible from class loader，常见于 dubbo 服务。\n解决办法：不要用 spring-boot-devtools。 参考链接：https://blog.csdn.net/zhailuxu/article/details/79305661\ndubbo 服务 java.io.IOException: invalid constant type: 18，日志类似如下：\nWrapped by: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.alibaba.dubbo.rpc.Protocol, cause: java.io.IOExc eption: invalid constant type: 18 at com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtension(ExtensionLoader.java:723) at com.alibaba.dubbo.common.extension.ExtensionLoader.getAdaptiveExtension(ExtensionLoader.java:455) ... 29 common frames omitted Wrapped by: java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extens tion interface com.alibaba.dubbo.rpc.Protocol, cause: java.io.IOException: invalid constant type: 18 at com.alibaba.dubbo.common.extension.ExtensionLoader.getAdaptiveExtension(ExtensionLoader.java:459) at com.alibaba.dubbo.config.ServiceConfig.\u0026lt;clinit\u0026gt;(ServiceConfig.java:51) ... 28 common frames omitted 原因：缺少 javassist 或 javassist 版本太低。目前可用的版本是 javassist:javassist:3.27.0-GA。\nSpring Auto Configuration 常见排除：\nAn attempt was made to call a method that does not exist. The attempt was made from the following location: org.springframework.boot.autoconfigure.mongo.MongoPropertiesClientSettingsBuilderCustomizer.applyUuidRepresentation(MongoPropertiesClientSettingsBuilderCustomizer.java:58) The following method did not exist: \u0026#39;com.mongodb.MongoClientSettings$Builder com.mongodb.MongoClientSettings$Builder.uuidRepresentation(org.bson.UuidRepresentation)\u0026#39; The calling method\u0026#39;s class, org.springframework.boot.autoconfigure.mongo.MongoPropertiesClientSettingsBuilderCustomizer, was loaded from the following location: Spring 默认增加很多 Auto Configuration，使用 support 时可能触发 Auto Configuration 但又缺少配置，或者依赖版本与 Spring Boot 不匹配，可主动排除掉。\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, MongoDataAutoConfiguration.class}) 关注 Spring Boot 默认 Path 解析器变更，Spring Boot 2.6 版本以后默认由 ANT_PATH_MATCHER 变为 PATH_PATTERN_PARSER。\n双斜线 // 以前是可以匹配成功，目前版本会返回 404，比如 http://localhost:8080//actuator/health。\n默认禁用了后缀匹配，比如 GET /projects/spring-boot.json 将不能匹配到 @GetMapping(\u0026quot;/projects/spring-boot\u0026quot;)。\n据说，中文不主动进行 URLEncode 也会受影响，比如原来 http://localhost/卫星实验室 是能成功，目前也会 404。\nPATH_PATTERN_PARSER 只支持末尾 ** 匹配，不支持中间路径 ** 正则匹配，比如：/api/**/query 不支持。\n功能说明和切换方式请参考官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.content-negotiation.\n参考资料 辅助迁移扫描工具\n从 Java 8 到 Java 17：https://github.com/adoptium/emt4j\nSpring Boot 迁移工具： https://github.com/spring-projects-experimental/spring-boot-migrator\n从 SpringMVC 迁移到 SpringBoot 的经验总结\nhttps://juejin.cn/post/6844903640361074696\nhttps://juejin.cn/post/6844903573453537294\nhttps://juejin.cn/post/7129751916002672654\n从 Java8 升级到 jdk17 的全过程记录\nhttps://juejin.cn/post/7258170075198259257\n从 JUnit 4 迁移到 JUnit 5\nhttps://zhuanlan.zhihu.com/p/144763642\n我服了！SpringBoot 升级后这服务我一个星期都没跑起来\nhttps://www.toutiao.com/article/7163602391366074916\nhttps://www.toutiao.com/article/7168780833636106760\nSpring Boot 2 到 Spring Boot 3 官方迁移指南\nhttps://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide\nhttps://www.baeldung.com/spring-boot-3-migration\nSpring Boot 2.7.6 升级 3.1.0 爬坑指北\nhttps://juejin.cn/post/7237029359135408165\nSpring Boot 3.1 的新特性、升级说明以及核心功能的改进\nhttps://juejin.cn/post/7280787657013002301\nhttps://juejin.cn/post/7170907270631718920\nWhy is PostConstruct not called\nhttps://stackoverflow.com/questions/18161682/why-is-postconstruct-not-called\n","date":"January 7, 2023","id":3,"permalink":"/docs/guides/migrating-spring-to-spring-boot/","summary":"从 Spring 到 Spring Boot，迁移升级快速入门以及各种踩坑记录。\n概述 从 Spring 到 Spring Boot，整体开发、运行方式主要变化。\n- 当前（老）模式 新模式（本地） 新模式（线上） 开发习惯 Spring + 外置 Tomcat Spring Boot（embed tomcat） Spring Boot War or Jar Java 版本 8、11、16、17 11、17（推荐）、21 11、17（推荐）、21 Tomcat 版本 8.","tags":"Spring Boot Java","title":"从 Spring 到 Spring Boot"},{"content":"Spring Boot 使用 Micrometer 集成 Prometheus 监控，5 分钟接入自定义监控指标，主要内容：\nMicrometer 介绍。 业务如何自定义指标，如何接入 Prometheus，实现方式和规范。 Micrometer 介绍 Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标，Micrometer 会负责完成与不同监控系统的适配工作。\nMicrometer 提供了多种度量指标类型（Timers、Guauges、Counters 等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus、OTLP 等。\n从 Spring Boot 2.x 开始使用 Micrometer 作为默认的监控门面接口， Think SLF4J, but for observability 。\nMicrometer 核心概念 Micrometer 中两个最核心的概念：计量器注册表 (MeterRegistry)，计量器 (Meter)。\nMeterRegistry\n内存注册表 (SimpleMeterRegistry): 在内存中保存每一个 Meter（指标）的最新值，并且不会将数据导出到任何地方。 组合注册表 (CompositeMeterRegistry): 可以添加多个注册表，用于将各个注册表组合起来，可以同时将指标发布到多个监控系统。Micrometer 提供了一个全局的 MeterRegistry，io.micrometer.core.instrument.Metrics 中持有一个静态 final 的 CompositeMeterRegistry 实例 globalRegistry。 普罗米修斯注册表 (PrometheusMeterRegistry): 当使用普罗米修斯监控时，引入 micrometer-registry-prometheus 依赖时会提供此种收集器，用于将指标数据转换为普罗米修斯识别的格式和导出数据等功能。 Meter（指标）\n监控数据的整个过程都是围绕着 Meter（指标）, 通过一个一个的 Meter（指标）数据来进行观察应用的状态。常用的指标如：\nCounter（计数器）: 单一计数指标，允许按固定数量递增，用来统计无上限数据。只允许递增。 Gauge（仪表盘）: 表示单个的变化的值，例如温度，气压。用于统计有上限可增可减的数据。在每次取样时，Gauge 会返回当前值。 Timer（计时器）: 通常用来记录事件的持续时间。Timer 会记录两类的数据，事件的数量和总的持续时间。 Tag（标签）\nMircrometer 通过 Tag（标签）实现了多维度的度量数据收集，通过 Tag 的命名可以推断出其指向的数据代表什么维度或是什么类型的度量指标。\n当前实现方式和要求 总体架构：Spring Boot Actuator + Micrometer + Prometheus + Granfana。\nSpring Boot Micrometer：提供监控门面 Api。 Spring Boot Actuator：提供监控指标采集服务，通过 /actuator/prometheus 获取数据。 Prometheus + Granfana：采集和存储数据，提供图表展示，根据告警规则发出告警。 总体实现步骤如下：\nSpring Boot Actuator 放开 prometheus http 访问，在配置文件中增加以下配置。\nmanagement.endpoint.prometheus.enabled=true management.endpoints.web.exposure.include=info,health,metrics,prometheus management.metrics.export.prometheus.enabled=true 创建 Prometheus ServiceMonitor，从 /actuator/prometheus path 采集指标，如果涉及多个 war 合并部署到一个 tomcat 的，从多个 path 采集。\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: labels: app.kubernetes.io/component: metrics release: eye2 name: eye-consumer namespace: test spec: endpoints: - interval: 30s honorLabels: true path: /client-biz/actuator/prometheus port: metrics - interval: 30s honorLabels: true path: /gateway-biz/actuator/prometheus port: metrics jobLabel: eye-consumer selector: matchLabels: app: eye-consumer 业务可通过 http://localhost:8080/actuator/metrics 查看指标是否已上报，通过 http://localhost:8080/actuator/prometheus 查看指标值。\n自定义 Metrics 指标 在 Spring Boot 中实现自定义指标非常简单，几种方式举例如下。\n像使用 slf4j 一样，使用 io.micrometer.core.instrument.Metrics 静态方式初始化一个指标，然后使用此指标直接操作。 使用 @Timed @Counted 注解。注意注解方式必须等方法调用后才能生成指标。而静态方法形式 io.micrometer.core.instrument.Metrics.counter立即就生成指标只是值为 0。另外注意 Spring 注解不支持 private、default 级别方法。 使用 Autowired MeterRegistry 创建自己的指标类型，适合一些动态 Tag 等高级定制场景。 import io.micrometer.core.annotation.Counted; import io.micrometer.core.instrument.Counter; import io.micrometer.core.instrument.Metrics; import org.springframework.stereotype.Service; @Service public class MicrometerSampleService { /** * 方式 1：像使用 slf4j 一样，使用 `io.micrometer.core.instrument.Metrics`静态方式初始化一个计数器，适用于名字和 Tag 固定的场景 */ private static final Counter failure = Metrics.counter(\u0026#34;fs.sms.send\u0026#34;, \u0026#34;result\u0026#34;, \u0026#34;failure\u0026#34;); @Autowired private MeterRegistry registry; private void sendSms() { try { // do something } catch (Exception e) { failure.increment(); } } /** * 方式 2：使用注解的方式，注意需要引入 spring-boot-starter-aop 依赖 */ @Counted(value = \u0026#34;fs.sms.send\u0026#34;, extraTags = {\u0026#34;provider\u0026#34;, \u0026#34;huawei\u0026#34;}) public void sendByHuawei() { this.sendSms(); } @Counted(value = \u0026#34;fs.sms.send\u0026#34;, extraTags = {\u0026#34;provider\u0026#34;, \u0026#34;ali\u0026#34;}) public void sendByAli() { this.sendSms(); } /** * 方式 3：使用 MeterRegistry，适合一些动态 Tag 等高级定制场景 * * @param result result */ public void countByResult(String result) { registry.counter(\u0026#34;fs.sms.send\u0026#34;, \u0026#34;result\u0026#34;, result).increment(); // or Counter.builder(\u0026#34;fs.sms.send\u0026#34;) .description(\u0026#34;send sms\u0026#34;) .tags(\u0026#34;result\u0026#34;, result) .register(registry) .increment(); } } Spring Boot 无法直接使用 @Timed @Counted 注解，需要引入切面支持，需要引入 spring-boot-starter-aop 依赖。\n@Configuration public class MicrometerAspectConfiguration { @Bean public CountedAspect countedAspect(MeterRegistry registry) { return new CountedAspect(registry); } @Bean public TimedAspect timedAspect(MeterRegistry registry) { return new TimedAspect(registry); } } 为了方便大家使用，已经在我们的 starter 里自动注入了以上 Bean，大家只需要引入以下两个 starter。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fxiaoke.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;metrics-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 自定义指标高级配置 Spring 默认注入的 MeterRegistry 是一个 CompositeMeterRegistry，如果想定制可注入自定义 MeterRegistryCustomizer Bean。\n@Configuration public class MicrometerConfiguration { @Bean MeterRegistryCustomizer\u0026lt;MeterRegistry\u0026gt; configurer() { return (registry) -\u0026gt; registry.config() .commonTags(\u0026#34;group\u0026#34;, \u0026#34;sample\u0026#34;) .commonTags(\u0026#34;application\u0026#34;, \u0026#34;sample\u0026#34;); } } 如果只是想为当前应用增加 Tag，可直接通过配置文件增加，示例如下。\nmanagement.metrics.tags.biz=sample management.metrics.tags.application=${spring.application.name} 自定义指标规范 指标和 Tag 命名约定使用英语句号分隔，全小写，Tag 可根据实际情况使用缩写。指标名在不同的 MeterRegistry 里会自动转换，比如在 Prometheus 会把 fs.sms.send 转换为 fs_sms_send。\n指标命名建议以 fs.application.action 为模板，避免与开源或其他项目组冲突。\n注意 Tag values 不能为 Null， 且必须是可枚举的某些固定类型便于统计。\n使用注解@Timed @Counted会默认增加 method、class、result、exception 这几个 Tag，注意不要与之冲突。\n公司和开源默认 Tag 如下，这些会被 ServiceMonitor 强制覆盖，业务不要自己定义。\nnamespace、application、service、container、pod、instance、job、endpoint、id 编码中如果需要 MeterRegistry，不允许引用具体实现（比如 Prometheus 的 io.prometheus.client.CollectorRegistry），而是使用 Micrometer 提供的统一接口 MeterRegistry。类比，在打印日志时不允许直接使用 logback 或 log4j api，而是使用 slf4j api.\n不要自己 new MeterRegistry，而是使用自动注入的或静态方法，因为我们可能随时在公司的 starter 增加自定义的配置。\n建议为指标加上 description 字段。\n最佳实践 合理规划 Tag，一个 Meter 具体类型需要通过名字和 Tag 作为它的唯一标识，这样做的好处是可以使用名字进行标记，通过不同的 Tag 去区分多种维度进行数据统计。\n反例 1（全部用 name 区分，无 Tag，重复计量）： Metrics.counter(\u0026#34;fs.sms.all\u0026#34;); Metrics.counter(\u0026#34;fs.sms.aliyun\u0026#34;); Metrics.counter(\u0026#34;fs.sms.huaweiyun\u0026#34;); 正例： Metrics.counter(\u0026#34;fs.sms.send\u0026#34;,\u0026#34;provider\u0026#34;,\u0026#34;ali\u0026#34;); Metrics.counter(\u0026#34;fs.sms.send\u0026#34;,\u0026#34;provider\u0026#34;,\u0026#34;huawei\u0026#34;); 避免无意义不可枚举的 Tag，混乱的 Tag 比无 Tag 更难管理。\n注意事项 注意引入的类名，有很多同名的类，使用 io.micrometer.core 包下的类。 ","date":"August 7, 2023","id":4,"permalink":"/docs/guides/spring-boot-micrometer/","summary":"Spring Boot 使用 Micrometer 集成 Prometheus 监控，5 分钟接入自定义监控指标，主要内容：\nMicrometer 介绍。 业务如何自定义指标，如何接入 Prometheus，实现方式和规范。 Micrometer 介绍 Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标，Micrometer 会负责完成与不同监控系统的适配工作。","tags":"Spring Boot Java","title":"Spring Boot 自定义监控指标"},{"content":"基于 Envoy + Java Agent 的智能路由服务实现方案介绍。\n核心需求 服务自动注册和发现，通过 Service Name 直接调用服务。当然基本的负载均衡策略、熔断降级限流等功能也要支持。 公司约定的路由策略，支持按照租户路由到特定环境的服务，比如 VIP、Gray、Sandbox 等。 多集群通信，同云内新老 K8S 集群路由打通，可通过 POD IP 互相通信。 跨云通信，支持通过 VPN 或代理，从专属云访问公有云服务。 整体架构 智能路由服务从逻辑上分为数据平面和控制平面，主要包含以下组件。\nNacos：服务注册中心，配置中心。 XDS Server：对接服务注册中心、配置中心，实现 CDS、LDS、RDS 协议将集群、服务、路由、灰度租户等配置下发到 Envoy。 Envoy + WASM Plugin：通过 Envoy 代理流量，自定义 WASM 插件实现按照租户、用户路由到不同服务，实现自定义负载均衡策略。 Java Agent：增强 Java 应用 Http Client，拦截 OkHttp、Apache Http Client、RestTemplate、OpenFeign 等客户端调用，将流量重定向到 Envoy，Envoy 再根据服务名路由到真实的 Pod，实现服务发现和灾备切换。 Nacos Service CRD：自定义 Nacos Service CRD，将 Service 注册到 Nacos 中作为一个永久实例，解决跨云、跨集群服务调用。比如跨云情况下注册的是一个公网地址或 VPN 可通的地址。 C4Context title 基于 Envoy + Java Agent 的智能路由服务 Enterprise_Boundary(dp, \"Data Plane\") { Container(appA, \"Application A\", \"Java,Agent\", \"Agent 拦截客户端重定向到 Envoy\") Container(envoy, \"Envoy Proxy\", \"Envoy,WASM\", \"代理所有入口流量\n基于租户、服务负载均衡\") Container(appB, \"Application B\", \"Java,Agent\", \"应用注册到服务中心\") Rel(appA, envoy, \"request by name\", \"http\") Rel(envoy, appB, \"http proxy \u0026 lb\", \"http\") UpdateRelStyle(appA, envoy, $offsetX=\"-40\",$offsetY=\"-40\") UpdateRelStyle(envoy, appB, $offsetX=\"-40\",$offsetY=\"-40\") } Enterprise_Boundary(cp, \"Control Plane\") { System(registry, \"服务注册\", \"服务注册，服务元数据\n配置管理，双向刷新\") Container(xdsServer, \"控制面板\", \"Java,Grpc\", \"对接服务注册中心配置中心\n实现 XDS 协议将配置下发到 Envoy\") System(config, \"配置管理\", \"服务注册，服务元数据\n配置管理，双向刷新\") Rel_L(xdsServer, registry, \"实时获取服务实例\") Rel_R(xdsServer, config, \"实时配置刷新\") UpdateRelStyle(xdsServer, registry, $offsetX=\"-40\",$offsetY=\"-20\") UpdateRelStyle(xdsServer, config, $offsetX=\"-40\",$offsetY=\"-20\") } Rel_U(xdsServer,envoy,\"通过 XDS 实现配置动态下发\",\"grpc\") Rel_D(appA, registry, \"服务注册，配置刷新\") Rel_D(appB, config, \"服务注册，配置刷新\") UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\") 方案对比 此方案原始的目标有几个：\n语言无关，可以不绑定 Java。目前看来这是个伪需求。 实现类似 Istio Ambient Mesh，剔除 Egress 流量代理，每个 Node 部署一个 Envoy Proxy，减少 Sidecar 资源开销。目前随着 Istio Ambient Mesh 成熟，这个优点反而也没有了。 对比 K8S 体系、Spring Cloud 体系，此方案优点：\n各服务实际上只需要注入服务中心，服务发现和负载均衡交给 Agent 和 Envoy，对于老的 Spring 项目也能直接使用，相对 Spring Cloud 轻量一些。 不需要引入 Istio 也能支持跨云、跨集群访问场景，Istio 相对还是比较重。 此方案缺点：\n本质上还是 Proxy 模式，Proxy 的所有缺点他都绕不过，比如：性能损耗、Http Keepalive 和 reset 响应。 对服务和配置实时刷新，要比 K8S、Spring Cloud 略微延迟，对高并发场景难免有中断。 单点故障影响范围太大，以及 Proxy 任何配置性错误都是致命的。 综上，随着 Istio Ambient Mesh 以及基于 eBPF 的 Cilium Mesh 的成熟，这个方案可能逐渐退出历史舞台。那么，使用 Spring Cloud 全家桶快速启动先让业务用起来，反而成了一个最简单的方案。\n功能实现方案 主要功能实现方式如下。\n服务注册 服务通过 nacos support 或 nacos starter 注册到服务中心，关注下 Nacos 数据模型：\nnamespace - group - service - cluster - instance: ip,port,metadata namespace 和 group 的设计目的是为了实现隔离。\n同 service 下 instance 唯一标记：ip + port + cluster。metadata 不作为唯一性标记。 同 namespace 不同 group 下 service 可以完全相同。 Nacos 模型 开源原生默认值 我们方案 namespace 租户/环境 ，默认 public 固定自定义值 group 组织/虚拟分组，默认 DEFAULT 默认 DEFAULT，如果某个组确认自己的服务不给组用可自定义 group service spring.application.name 默认也是 spring.application.name，子模块名 cluster 虚拟，a k8s cluster/ a AZ 线上发布系统的“环境”英文名，实际是 k8s 的 namespace instance 一个 Java 应用，一个 jar 或一个 war 服务 一个 jar 或一个 war 服务 注册实例信息约束：\nserviceName: appName.modeleName 应用的子模块名，目前的字符和长度限制都能满足要求 clusterName: 发布系统定义的“环境”英文名 ip: pod ip port: container port enabled： true or false 用于主动控制上下线，下线保留实例不承载流量 weight：权重 metadata： - contextPath： 推荐等同子模块名，要求必须有且不能随意变更，可以是根目录 - preserved.register.source: 官方自动加，如 Spring Cloud、Dubbo。 - secure：官方开源客户端自动加 boolean 值，标记 http or https 协议 - protocol：通信协议，http/grpc/dubbo - version：版本标记，后续扩展路由策略支持多版本或限定版本。 - runtime：k8s info、node info。 对于专属云访问公有云，目前是通过 VPN 代理方式，那么在专属云访问公有云时，如何通过 Service 名字映射到公有云服务呢。 我们会在专属云内，手动（优化为自定义 K8S CRD，联动 GitOps 自动部署）在 Nacos 中增加一个永久性实例（关于永久性实例和临时实例的说明请参考官方文档），只是这个实例的 IP 不是 POD IP，是通过 VPN 可通的 IP。\n服务发现 调用方可使用 OkHttp、RestTemplate、OpenFeign 等客户端，直接使用服务名调用，比如：GET http://user-service/users。\n服务发现和负载均衡策略，其实依赖三个组件：XDS Server、Envoy + WASM、Java Agent。\n基本实现步骤：\nXDS Server 从 Nacos 实时获取最新的服务和实例列表，从配置中心获取服务灰度列表，通过 ADS 协议实时下发到 Envoy。 我们为 Envoy 定制了一个 WASM Plugin，这个 Plugin 支持通过租户路由到 Gray、VIP、Sandbox 等不同环境，Envoy 通过环境标记负载到真实的 POD 上。 Java Agent 增强 OkHttp 增加自定义 intercept，拦截服务名重定向到 Envoy，Envoy 根据服务名、路径、Header 路由到真实的后端服务。 我们的 RestTemplate、OpenFeign 客户端做了定制，底层连接器都切换到了 OkHttp。 客户端调用时，Header 中增加租户信息。 客户端调用时不需要关心服务的 contextPath，Envoy 会自动追加 contextPath。 路由和负载均衡规则 运行环境定义： Gray: foneshare-gray 用于常规发布的灰度过程；承载 QA 专用在线测试租户 Stage: foneshare-stage 用于大版本发布的灰度过程，承载 QA 专用在线测试租户、必要的真实租户 Urgent: foneshare-urgent 用于解决线上 vip、svip 面临的紧急 bug, 承载 bug 相关的 vip、svip 租户 Normal: foneshare、foneshare01、foneshare02、foneshare03、foneshare04 承载 vip 之外的租户 VIP: foneshare-vip 承载 vip 的租户 SVIP: 一个 foneshare-svip 承载多个 svip 租户 SSVIP: 一个环境承担一个租户，如 foneshare-yqsl 承载 ssvip 租户 Sandbox：所有以 _sandbox 结尾的租户都会路由到 Sandbox 环境。\n环境路由优先级从高到低：\nSSVIP \u0026gt; Gray \u0026gt; Urgent \u0026gt; Stage \u0026gt; SVIP \u0026gt; VIP \u0026gt; Sandbox \u0026gt; Normal\n对于同一租户，既配置在 vip 的灰度名单，同时又配置到 gray 的灰度名单，实际路由时走哪个环境：\nP1，最高优先级，gray、urgent、yqsl 等专属环境，tenantId 匹配任意环境就会返回； P2，第 2 优先级，stage； P3，第 3 优先级，svip； P4，第 4 优先级，vip； P5，第 5 优先级，sandbox； P6，默认 normal，上述环境均未匹配到后，路由到 normal 环境。\n按照上述顺序的原则，如一家租户既配置在 vip 同时又配置在 gray，实际会路由到 gray 环境。 注意：\n这里路由到 gray是指 gray 中存在对应的服务，如果 gray 中不存在服务，会按匹配到的优先级（vip）继续找，直到找到可用的服务。 命中条件：租户在这个环境的这个服务名单里（租户+服务唯一确定）。 沙箱用户比较特殊，是 EA 以 _sandbox 结尾。 Envoy 配置下发和更新 Envoy 通过文件系统或查询管理服务器发现其各种动态资源。这些发现服务及其相应的 API 统称为 xDS。\n我们的控制面 XDS Server 只实现了聚合发现服务（ADS），通过 ADS 使用单个流推送 CDS、EDS 和 RDS 资源，实现无中断的更新。\nXDS Server 缓存了各个 Envoy 的 grpc connection，同时响应 Nacos 和配置中心的更新事件，收到更新后再通过 grpc 推送到各个 Envoy 终端。\n使用限制 请求 Header 必须要包含 x-fs-ea 或 x-fs-ei 参数（推荐 x-fs-ea），否则无法支持按租户路由。 同一个服务在同一个环境，发布流程中的 contextPath 必须一致，因为是按环境类型统一路由只能有一个 contextPath。 配置文件变更需要 30s 后才能生效，这取决了 CMS 配置系统拉取方式。 新增加服务无法立即感知到（是新的服务，不是服务实例，实例能即时感知），我们是 10 分钟扫描一次服务，判断有无服务变更。 Nacos 服务端部署 部署形态：\n公有云一套，承接公有云新老集群。 每个专属云有独立的一套。 注意事项：\nNacos 需要放开 http（8848）和 grcp（9848、9849）端口。 认证：使用用户名密码模式。不同组创建独立的用户名密码，单独授权。默认的用户nacos不要用且权限不足。 连接时配置的 namespace 实际是 namespace id，可以考虑创建 namespace 时主动设置 namespace id 等同于 namespace name，便于定位，误删或迁移的时候能保证 ID 不变。 ","date":"August 7, 2023","id":5,"permalink":"/docs/guides/service-mesh-envoy/","summary":"基于 Envoy + Java Agent 的智能路由服务实现方案介绍。\n核心需求 服务自动注册和发现，通过 Service Name 直接调用服务。当然基本的负载均衡策略、熔断降级限流等功能也要支持。 公司约定的路由策略，支持按照租户路由到特定环境的服务，比如 VIP、Gray、Sandbox 等。 多集群通信，同云内新老 K8S 集群路由打通，可通过 POD IP 互相通信。 跨云通信，支持通过 VPN 或代理，从专属云访问公有云服务。 整体架构 智能路由服务从逻辑上分为数据平面和控制平面，主要包含以下组件。","tags":"Spring Boot Java Envoy","title":"基于 Envoy 的智能路由服务"},{"content":"","date":"September 7, 2023","id":6,"permalink":"/docs/guides/","summary":"","tags":"","title":"Guides"},{"content":"","date":"September 7, 2023","id":7,"permalink":"/docs/reference/","summary":"","tags":"","title":"Reference"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"September 7, 2023","id":8,"permalink":"/docs/reference/example/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.","tags":"","title":"Example Reference"},{"content":"","date":"September 7, 2023","id":9,"permalink":"/docs/","summary":"","tags":"","title":"Docs"},{"content":"","date":"September 7, 2023","id":10,"permalink":"/privacy/","summary":"","tags":"","title":"Privacy Policy"},{"content":"","date":"September 7, 2023","id":11,"permalink":"/","summary":"","tags":"","title":"卫星实验室"},{"content":"","date":"September 7, 2023","id":12,"permalink":"/tags/k8s/","summary":"","tags":"","title":"k8s"},{"content":"","date":"September 7, 2023","id":13,"permalink":"/tags/","summary":"","tags":"","title":"Tags"},{"content":"","date":"August 7, 2023","id":14,"permalink":"/categories/","summary":"","tags":"","title":"Categories"},{"content":"","date":"August 7, 2023","id":15,"permalink":"/tags/envoy/","summary":"","tags":"","title":"Envoy"},{"content":"","date":"August 7, 2023","id":16,"permalink":"/tags/java/","summary":"","tags":"","title":"Java"},{"content":"","date":"August 7, 2023","id":17,"permalink":"/categories/java/","summary":"","tags":"","title":"Java"},{"content":"","date":"August 7, 2023","id":18,"permalink":"/tags/spring-boot/","summary":"","tags":"","title":"Spring Boot"},{"content":"","date":"August 7, 2023","id":19,"permalink":"/categories/spring-boot/","summary":"","tags":"","title":"Spring Boot"},{"content":"","date":"January 1, 0001","id":20,"permalink":"/contributors/","summary":"","tags":"","title":"Contributors"}]