[{"content":"卫星实验室，一个专注于研究卫星以及 CRM 的开源组织。\n此项目为卫星实验室主页 xlabs.club 的源码，记录常用文档和零碎博客，欢迎提交 PR 开源共建。\n本地开发 本项目使用 Hugo 开发，使用 Doks 作为主题，本地开发时先安装 Nodejs，然后使用 npm（或 pnpm） 安装 Hugo。\n# 安装 npm 依赖包 npm install # 启动 Web，然后浏览器访问 http://localhost:1313/即可浏览效果 npm run dev # 更多命令请参考 package.json License 本文档采用 CC BY-NC 4.0 许可协议。\n","date":"September 7, 2023","id":0,"permalink":"/docs/guides/introduction/","summary":"卫星实验室，一个专注于研究卫星以及 CRM 的开源组织。\n此项目为卫星实验室主页 xlabs.club 的源码，记录常用文档和零碎博客，欢迎提交 PR 开源共建。\n本地开发 本项目使用 Hugo 开发，使用 Doks 作为主题，本地开发时先安装 Nodejs，然后使用 npm（或 pnpm） 安装 Hugo。\n# 安装 npm 依赖包 npm install # 启动 Web，然后浏览器访问 http://localhost:1313/即可浏览效果 npm run dev # 更多命令请参考 package.","tags":"","title":"Introduction"},{"content":"","date":"September 7, 2023","id":1,"permalink":"/blog/","summary":"","tags":"","title":"Blog"},{"content":"从 Spring 到 Spring Boot，迁移升级快速入门以及各种踩坑记录。\n概述 从 Spring 到 Spring Boot，整体开发、运行方式主要变化。\n- 当前（老）模式 新模式（本地） 新模式（线上） 开发习惯 Spring + 外置 Tomcat Spring Boot（embed tomcat） Spring Boot War or Jar Java 版本 8、11、16、17 11、17（推荐）、21 11、17（推荐）、21 Tomcat 版本 8.x、9.x 9.x 9.x（推荐）、10.x 说明：\n理论上支持 Java11，但是要求业务方尽量使用 Java17。其他版本都是实验性质尽量兼容。 线上运行支持 Spring Boot jar 直接运行，但主要业务仍推荐以 war + tomcat 为主。如果希望以 java -jar 方式运行，参考下面的章节“jar 方式运行”描述。 目前 Spring Boot 主要推行版本是 2.7.x。 3.x 版本逐渐适配中。 快速开始 线下支撑系统导航，点击 脚手架 进入 spring start 页面，按自己需求选择模块，生成自己业务模式初始化代码。 写（Copy）业务代码到项目里，修改 pom.xml 根据需要添加新的依赖。 查看本文档中 遇见问题及解决方案 章节，注意如果是老项目迁移，这一步很重要。 本地开发工具启动 main 方法。 上线发布系统，选择 tomcat9:openjdk17 镜像，并勾选 镜像 JDK 版本编译代码。 以上生成的一个最简略的代码结构，更多复杂使用方式参考下方主要 starter 使用说明。\n主要 starter 使用说明 文档会延后，代码不会骗人，更多说明参考各个项目源码的 README，README 会实时更新。\nfxiaoke-spring-cloud-parent 目前有两个公司级父 pom：\n旧：com.fxiaoke.common.fxiaoke-parent-pom 用于原 Spring + Tomcat 方式开发。 新：com.fxiaoke.cloud.fxiaoke-spring-cloud-parent 用于 Spring Boot/Cloud 方式开发。 注意：\nfxiaoke-spring-cloud-parent 导入了 fxiaoke-parent-pom，所以纷享包版本都是一致的，但是三方包比如 spring/netty/okhttp 会随 Spring Boot 版本。 Maven 项目 parent 统一使用公司新 parent pom，这里定义了 Spring Boot、Spring Cloud 以及内部定制的各种 support 和 starter 版本号。\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.fxiaoke.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fxiaoke-spring-cloud-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 注意使用最新版本，可以从脚手架里获取最新版本 --\u0026gt; \u0026lt;version\u0026gt;2.7.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; 主要升级项需关注：\n老项目切换到 Spring Boot 先分析实际生效的 maven dependency，关注下核心包版本是否有大的升级，是否可能对业务造成影响。 Spock and Groovy：Spock 由原来的 1.x 升级到 2.x 版本，同时 Groovy 升级到 4.x 版本，Junit4 升级到 Junit5。 spring-boot-starter-actuator 目前强制依赖 spring-boot-starter-actuator，容器镜像里使用它实现健康检查。 另外强制依赖 spring-boot-starter-web，因为有些基础组件依赖了 ServletContext。\n注意： actuator 的引入会带来一些额外收益，之前我们健康检测只检查服务端口是否有响应，而 actuator 默认还额外检查各个中间件的状态，业务方可根据需要自行增加或删除某些中间件的状态到健康检测服务，具体方式和更多高级应用参考 spring-boot-starter-actuator 官方文档。\ncms-spring-cloud-starter 配置中心 starter，类似 spring-cloud-consul/nacos/config，对接配置中心，实现配置文件动态加载、刷新，代替原 ReloadablePropertySourcesPlaceholderConfigurer。\n使用步骤：\n引入 starter。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fxiaoke.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cms-spring-cloud-starter\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本号建议不写，使用 parent 定义好的版本 --\u0026gt; \u0026lt;/dependency\u0026gt; 增加 src/main/resources/application.properties 文件，内容如下。\n# 当前模块名，必填，必须全局唯一，一般和 maven 子模块保持一致 spring.application.name=cms-starter-sample # 配置导入，这一行必须写。但是配置文件本身是否必须是通过 optional 控制的 spring.config.import=optional:cms:${spring.application.name} 我们使用 spring.config.import 固定格式为 optional:cms:file-name。 optional 表示这个文件可选，配置中心不存在的时候也允许启动，cms 是固定字符代表对接 fs 配置中心。\n在 CMS 配置中心创建需要的配置文件，文件名为 spring-cloud-${spring.application.name}，其中${spring.application.name}替换成真正的文件名，注意当前版本自动追加了前缀spring-cloud-且不允许修改。\n代码中使用几种方式参考 sample 代码，文档查看 spring 官方ConfigurationProperties和 @Value 说明。\n配置变更后，如果想响应变更事件，实现自己逻辑，自定义类中implements ApplicationListener\u0026lt;RefreshScopeRefreshedEvent\u0026gt;\n配置加解密，在配置中心中有个加密功能框（如果看不到可能是没有权限），先使用本 starter 的秘钥加密，使用固定格式 ENC（加密后的内容）配置到文件里，在 java 里 get value 就是已经解密后的了。例如：\nsample.sensitive=ENC(30E239E0958AF3179C7E8EBA3DF618FD) 响应配置更新：\n对于使用使用 ConfigurationProperties 映射的对象类，从对象中每次 get 的值都是刷新后的。推荐这种方式。\n@Data @Configuration @ConfigurationProperties(prefix = \u0026#34;sample\u0026#34;) public class SampleProperties { private String name; } @RefreshScope + @Value 获取 Value 注解的新值。\n@Service @RefreshScope public class ValueService { @Value(\u0026#34;${sample.over.value}\u0026#34;) @Getter private String watchValue; } 监听 RefreshScopeRefreshedEvent 事件。\n@EventListener(RefreshScopeRefreshedEvent.class) public void handlerPropertiesChangeEvent(RefreshScopeRefreshedEvent event) { //此时配置 Bean 已刷新完成，处理自己的业务逻辑 } jar 方式运行 如果不使用外置 Tomcat，使用 java -jar 方式直接运行，首先打包模式为 jar 并在发布时增加环境变量 SPRING_BOOT_JAR_APP=true。\n与外置 Tomcat 模式差别：\njar 模式一个 pod 内只能部署一个模块，不支持多模块合并部署。 jar 模式不会自动把 jar 解压成文件夹（war 模式会），所以关于文件资源的读写要特别注意，参考下面的问题描述章节。 老项目迁移升级步骤 改 pom.xml：修改 parent，引入必须的 starter，删除所有关于 Spring/logback/junit 的依赖项（由 Spring Boot Starter 自动引入），插件切换到 spring-boot-maven-plugin。 原有的 xml 配置，可以改为注解形式，也可以不改直接 @ImportResource 使用。 注意配置扫描范围，原来 xml 中可能是配置是某几个包，Spring Boot 默认扫描 Application.java 所在包，范围可能扩大。 删除原来 web.xml 相关配置，如果有额外的 filter、servlet，需要额外定义 Bean 注入。 Unit Test 更换注解，目前默认 junit 版本是 junit5，原 junit4 注解有较大变更，详细请参考下面的参考资料。 迁移辅助工具 EMT4J\n通过静态扫描指导从 Java 8 升级到 Java 17 需要注意的变更项。\nspring-boot-migrator\nSpring Boot 迁移工具，通过扫描输出 从 Spring 到 Spring Boot，以及 Spring Boot 3 迁移指导意见。\nWar 配置转移 If you try to migrate a Java legacy application to Spring Boot you will find out that Spring Boot ignores the web.xml file when it is run as embedded container.\nwebapp web.xml 配置如何转移到 spring boot war 形式。 参考：https://www.baeldung.com/spring-boot-dispatcherservlet-web-xml\n遇见问题及解决方案 下面记录一些比较常见的问题，更多问题请参考下面章节中的参考资料，里面的问题很有参考价值。\ncom.google.common.io.Resources#getResource 无法获取到 jar 包内资源\n如果是 java -jar 模式运行， Thread.currentThread().getContextClassLoader().getResource(resourceName) 形式的调用都无法获取 jar 包内资源，可考虑使用 InputStream resourceFile = getClass().getResourceAsStream(resourceName); 方式代替。\nPostConstruct 和 PreDestroy 注解不生效\n参考链接 https://stackoverflow.com/questions/18161682/why-is-postconstruct-not-called 先逐个排除。\n我所遇到的原因：PostConstruct、PreDestroy 等注解可能存在多个实现或者过个版本，比如以下 jar 包都可能包含：\njavax.annotation-api-1.3.2.jar jakarta.annotation-api-1.3.5.jar jboss-annotations-api_1.3_spec-2.0.1.Final.jar 解决方法：排除依赖，只保留 jakarta.annotation-api 一种，且只能有一个版本。\nkafka 使用报错，日志类似如下：\nERROR c.f.s.SenderManager cannot send, org.apache.kafka.common.KafkaException: org.apache.kafka.clients.producer.internals.DefaultPartitioner is not an instance of org.apache.kafka.clients.producer.Partitioner 原因：因为 classpath 下包含多个不同版本的 kafka-client.jar，检查依赖项，确保只引用一个版本。\n告警：SLF4J: Class path contains multiple SLF4J bindings.\n多个 jar 包含 SLF4J 实现，或引入了多个 logback 版本，请根据提示排除不需要的 jar 包。\nXML 中使用 AOP 注解，运行期报错如下（建议用到 AOP 的提前检查，因为运行期才会报错）：JoinPointMatch ClassNotFoundException\nCaused by: java.lang.ClassNotFoundException: org.aspectj.weaver.tools.JoinPointMatch at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1412) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1220) ... 58 more 依赖 spring aop，请确认是否引入 spring-boot-starter-aop。\n本地使用 Java 17 启动，类似如下报错。\nERROR o.s.b.SpringApplication Application run failed java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not \u0026#34;opens java.lang\u0026#34; to unnamed module @443118b0 at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) at com.alibaba.dubbo.common.compiler.support.JavassistCompiler.doCompile(JavassistCompiler.java:123) [6 skipped] at com.alibaba.dubbo.common.compiler.support.AbstractCompiler.compile(AbstractCompiler.java:59) at com.alibaba.dubbo.common.compiler.support.AdaptiveCompiler.compile(AdaptiveCompiler.java:46) 本地命令行中启动参数里主动追加以下参数（这些参数在发布系统的镜像里默认已经加了），IDEA 启动是设置到VM options里：\n--add-opens=java.base/java.lang.reflect=ALL-UNNAMED --add-opens=java.base/java.math=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED Bean 重复定义错误，报错信息类似如下。\nThe bean \u0026#39;eieaConverterImpl\u0026#39;, defined in class path resource [spring/ei-ea-converter.xml], could not be registered. A bean with that name has already been defined in class path resource [spring/ei-ea-converter.xml] and overriding is disabled. Action: Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true 可能因为注解扫描范围增广或者有同样包多版本引入，导致扫描到多个。确认多处定义是否一致，如果不一致查看原项目哪个生效，以生效为准。如果一致，找到定义的地方查看是否能整个文件排除掉，实在不能在 application.properties 中设置 spring.main.allow-bean-definition-overriding=true 可解决。\n如下报错 class xxx is not visible from class loader，常见于 dubbo 服务。\n解决办法：不要用 spring-boot-devtools。 参考链接：https://blog.csdn.net/zhailuxu/article/details/79305661\ndubbo 服务 java.io.IOException: invalid constant type: 18，日志类似如下：\nWrapped by: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.alibaba.dubbo.rpc.Protocol, cause: java.io.IOExc eption: invalid constant type: 18 at com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtension(ExtensionLoader.java:723) at com.alibaba.dubbo.common.extension.ExtensionLoader.getAdaptiveExtension(ExtensionLoader.java:455) ... 29 common frames omitted Wrapped by: java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extens tion interface com.alibaba.dubbo.rpc.Protocol, cause: java.io.IOException: invalid constant type: 18 at com.alibaba.dubbo.common.extension.ExtensionLoader.getAdaptiveExtension(ExtensionLoader.java:459) at com.alibaba.dubbo.config.ServiceConfig.\u0026lt;clinit\u0026gt;(ServiceConfig.java:51) ... 28 common frames omitted 原因：缺少 javassist 或 javassist 版本太低。目前可用的版本是 javassist:javassist:3.27.0-GA。\nSpring Auto Configuration 常见排除：\nAn attempt was made to call a method that does not exist. The attempt was made from the following location: org.springframework.boot.autoconfigure.mongo.MongoPropertiesClientSettingsBuilderCustomizer.applyUuidRepresentation(MongoPropertiesClientSettingsBuilderCustomizer.java:58) The following method did not exist: \u0026#39;com.mongodb.MongoClientSettings$Builder com.mongodb.MongoClientSettings$Builder.uuidRepresentation(org.bson.UuidRepresentation)\u0026#39; The calling method\u0026#39;s class, org.springframework.boot.autoconfigure.mongo.MongoPropertiesClientSettingsBuilderCustomizer, was loaded from the following location: Spring 默认增加很多 Auto Configuration，使用 support 时可能触发 Auto Configuration 但又缺少配置，或者依赖版本与 Spring Boot 不匹配，可主动排除掉。\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, MongoDataAutoConfiguration.class}) 关注 Spring Boot 默认 Path 解析器变更，Spring Boot 2.6 版本以后默认由 ANT_PATH_MATCHER 变为 PATH_PATTERN_PARSER。\n双斜线 // 以前是可以匹配成功，目前版本会返回 404，比如 http://localhost:8080//actuator/health。\n默认禁用了后缀匹配，比如 GET /projects/spring-boot.json 将不能匹配到 @GetMapping(\u0026quot;/projects/spring-boot\u0026quot;)。\n据说，中文不主动进行 URLEncode 也会受影响，比如原来 http://localhost/卫星实验室 是能成功，目前也会 404。\nPATH_PATTERN_PARSER 只支持末尾 ** 匹配，不支持中间路径 ** 正则匹配，比如：/api/**/query 不支持。\n功能说明和切换方式请参考官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.content-negotiation.\n参考资料 辅助迁移扫描工具\n从 Java 8 到 Java 17：https://github.com/adoptium/emt4j\nSpring Boot 迁移工具： https://github.com/spring-projects-experimental/spring-boot-migrator\n从 SpringMVC 迁移到 SpringBoot 的经验总结\nhttps://juejin.cn/post/6844903640361074696\nhttps://juejin.cn/post/6844903573453537294\nhttps://juejin.cn/post/7129751916002672654\n从 Java8 升级到 jdk17 的全过程记录\nhttps://juejin.cn/post/7258170075198259257\n从 JUnit 4 迁移到 JUnit 5\nhttps://zhuanlan.zhihu.com/p/144763642\n我服了！SpringBoot 升级后这服务我一个星期都没跑起来\nhttps://www.toutiao.com/article/7163602391366074916\nhttps://www.toutiao.com/article/7168780833636106760\nSpring Boot 2 到 Spring Boot 3 官方迁移指南\nhttps://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide\nhttps://www.baeldung.com/spring-boot-3-migration\nSpring Boot 2.7.6 升级 3.1.0 爬坑指北\nhttps://juejin.cn/post/7237029359135408165\nSpring Boot 3.1 的新特性、升级说明以及核心功能的改进\nhttps://juejin.cn/post/7280787657013002301\nhttps://juejin.cn/post/7170907270631718920\nWhy is PostConstruct not called\nhttps://stackoverflow.com/questions/18161682/why-is-postconstruct-not-called\n","date":"January 7, 2023","id":2,"permalink":"/docs/guides/migrating-spring-to-spring-boot/","summary":"从 Spring 到 Spring Boot，迁移升级快速入门以及各种踩坑记录。\n概述 从 Spring 到 Spring Boot，整体开发、运行方式主要变化。\n- 当前（老）模式 新模式（本地） 新模式（线上） 开发习惯 Spring + 外置 Tomcat Spring Boot（embed tomcat） Spring Boot War or Jar Java 版本 8、11、16、17 11、17（推荐）、21 11、17（推荐）、21 Tomcat 版本 8.","tags":"Spring Boot Java","title":"从 Spring 到 Spring Boot"},{"content":"Spring Boot 使用 Micrometer 集成 Prometheus 监控，5 分钟接入自定义监控指标，主要内容：\nMicrometer 介绍。 业务如何自定义指标，如何接入 Prometheus，实现方式和规范。 Micrometer 介绍 Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标，Micrometer 会负责完成与不同监控系统的适配工作。\nMicrometer 提供了多种度量指标类型（Timers、Guauges、Counters 等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus、OTLP 等。\n从 Spring Boot 2.x 开始使用 Micrometer 作为默认的监控门面接口， Think SLF4J, but for observability 。\nMicrometer 核心概念 Micrometer 中两个最核心的概念：计量器注册表 (MeterRegistry)，计量器 (Meter)。\nMeterRegistry\n内存注册表 (SimpleMeterRegistry): 在内存中保存每一个 Meter（指标）的最新值，并且不会将数据导出到任何地方。 组合注册表 (CompositeMeterRegistry): 可以添加多个注册表，用于将各个注册表组合起来，可以同时将指标发布到多个监控系统。Micrometer 提供了一个全局的 MeterRegistry，io.micrometer.core.instrument.Metrics 中持有一个静态 final 的 CompositeMeterRegistry 实例 globalRegistry。 普罗米修斯注册表 (PrometheusMeterRegistry): 当使用普罗米修斯监控时，引入 micrometer-registry-prometheus 依赖时会提供此种收集器，用于将指标数据转换为普罗米修斯识别的格式和导出数据等功能。 Meter（指标）\n监控数据的整个过程都是围绕着 Meter（指标）, 通过一个一个的 Meter（指标）数据来进行观察应用的状态。常用的指标如：\nCounter（计数器）: 单一计数指标，允许按固定数量递增，用来统计无上限数据。只允许递增。 Gauge（仪表盘）: 表示单个的变化的值，例如温度，气压。用于统计有上限可增可减的数据。在每次取样时，Gauge 会返回当前值。 Timer（计时器）: 通常用来记录事件的持续时间。Timer 会记录两类的数据，事件的数量和总的持续时间。 Tag（标签）\nMircrometer 通过 Tag（标签）实现了多维度的度量数据收集，通过 Tag 的命名可以推断出其指向的数据代表什么维度或是什么类型的度量指标。\n当前实现方式和要求 总体架构：Spring Boot Actuator + Micrometer + Prometheus + Granfana。\nSpring Boot Micrometer：提供监控门面 Api。 Spring Boot Actuator：提供监控指标采集服务，通过 /actuator/prometheus 获取数据。 Prometheus + Granfana：采集和存储数据，提供图表展示，根据告警规则发出告警。 总体实现步骤如下：\nSpring Boot Actuator 放开 prometheus http 访问，在配置文件中增加以下配置。\nmanagement.endpoint.prometheus.enabled=true management.endpoints.web.exposure.include=info,health,metrics,prometheus management.metrics.export.prometheus.enabled=true 创建 Prometheus ServiceMonitor，从 /actuator/prometheus path 采集指标，如果涉及多个 war 合并部署到一个 tomcat 的，从多个 path 采集。\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: labels: app.kubernetes.io/component: metrics release: eye2 name: eye-consumer namespace: test spec: endpoints: - interval: 30s honorLabels: true path: /client-biz/actuator/prometheus port: metrics - interval: 30s honorLabels: true path: /gateway-biz/actuator/prometheus port: metrics jobLabel: eye-consumer selector: matchLabels: app: eye-consumer 业务可通过 http://localhost:8080/actuator/metrics 查看指标是否已上报，通过 http://localhost:8080/actuator/prometheus 查看指标值。\n自定义 Metrics 指标 在 Spring Boot 中实现自定义指标非常简单，几种方式举例如下。\n像使用 slf4j 一样，使用 io.micrometer.core.instrument.Metrics 静态方式初始化一个指标，然后使用此指标直接操作。 使用 @Timed @Counted 注解。注意注解方式必须等方法调用后才能生成指标。而静态方法形式 io.micrometer.core.instrument.Metrics.counter立即就生成指标只是值为 0。另外注意 Spring 注解不支持 private、default 级别方法。 使用 Autowired MeterRegistry 创建自己的指标类型，适合一些动态 Tag 等高级定制场景。 import io.micrometer.core.annotation.Counted; import io.micrometer.core.instrument.Counter; import io.micrometer.core.instrument.Metrics; import org.springframework.stereotype.Service; @Service public class MicrometerSampleService { /** * 方式 1：像使用 slf4j 一样，使用 `io.micrometer.core.instrument.Metrics`静态方式初始化一个计数器，适用于名字和 Tag 固定的场景 */ private static final Counter failure = Metrics.counter(\u0026#34;fs.sms.send\u0026#34;, \u0026#34;result\u0026#34;, \u0026#34;failure\u0026#34;); @Autowired private MeterRegistry registry; private void sendSms() { try { // do something } catch (Exception e) { failure.increment(); } } /** * 方式 2：使用注解的方式，注意需要引入 spring-boot-starter-aop 依赖 */ @Counted(value = \u0026#34;fs.sms.send\u0026#34;, extraTags = {\u0026#34;provider\u0026#34;, \u0026#34;huawei\u0026#34;}) public void sendByHuawei() { this.sendSms(); } @Counted(value = \u0026#34;fs.sms.send\u0026#34;, extraTags = {\u0026#34;provider\u0026#34;, \u0026#34;ali\u0026#34;}) public void sendByAli() { this.sendSms(); } /** * 方式 3：使用 MeterRegistry，适合一些动态 Tag 等高级定制场景 * * @param result result */ public void countByResult(String result) { registry.counter(\u0026#34;fs.sms.send\u0026#34;, \u0026#34;result\u0026#34;, result).increment(); // or Counter.builder(\u0026#34;fs.sms.send\u0026#34;) .description(\u0026#34;send sms\u0026#34;) .tags(\u0026#34;result\u0026#34;, result) .register(registry) .increment(); } } Spring Boot 无法直接使用 @Timed @Counted 注解，需要引入切面支持，需要引入 spring-boot-starter-aop 依赖。\n@Configuration public class MicrometerAspectConfiguration { @Bean public CountedAspect countedAspect(MeterRegistry registry) { return new CountedAspect(registry); } @Bean public TimedAspect timedAspect(MeterRegistry registry) { return new TimedAspect(registry); } } 为了方便大家使用，已经在我们的 starter 里自动注入了以上 Bean，大家只需要引入以下两个 starter。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fxiaoke.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;metrics-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 自定义指标高级配置 Spring 默认注入的 MeterRegistry 是一个 CompositeMeterRegistry，如果想定制可注入自定义 MeterRegistryCustomizer Bean。\n@Configuration public class MicrometerConfiguration { @Bean MeterRegistryCustomizer\u0026lt;MeterRegistry\u0026gt; configurer() { return (registry) -\u0026gt; registry.config() .commonTags(\u0026#34;group\u0026#34;, \u0026#34;sample\u0026#34;) .commonTags(\u0026#34;application\u0026#34;, \u0026#34;sample\u0026#34;); } } 如果只是想为当前应用增加 Tag，可直接通过配置文件增加，示例如下。\nmanagement.metrics.tags.biz=sample management.metrics.tags.application=${spring.application.name} 自定义指标规范 指标和 Tag 命名约定使用英语句号分隔，全小写，Tag 可根据实际情况使用缩写。指标名在不同的 MeterRegistry 里会自动转换，比如在 Prometheus 会把 fs.sms.send 转换为 fs_sms_send。\n指标命名建议以 fs.application.action 为模板，避免与开源或其他项目组冲突。\n注意 Tag values 不能为 Null， 且必须是可枚举的某些固定类型便于统计。\n使用注解@Timed @Counted会默认增加 method、class、result、exception 这几个 Tag，注意不要与之冲突。\n公司和开源默认 Tag 如下，这些会被 ServiceMonitor 强制覆盖，业务不要自己定义。\nnamespace、application、service、container、pod、instance、job、endpoint、id 编码中如果需要 MeterRegistry，不允许引用具体实现（比如 Prometheus 的 io.prometheus.client.CollectorRegistry），而是使用 Micrometer 提供的统一接口 MeterRegistry。类比，在打印日志时不允许直接使用 logback 或 log4j api，而是使用 slf4j api.\n不要自己 new MeterRegistry，而是使用自动注入的或静态方法，因为我们可能随时在公司的 starter 增加自定义的配置。\n建议为指标加上 description 字段。\n最佳实践 合理规划 Tag，一个 Meter 具体类型需要通过名字和 Tag 作为它的唯一标识，这样做的好处是可以使用名字进行标记，通过不同的 Tag 去区分多种维度进行数据统计。\n反例 1（全部用 name 区分，无 Tag，重复计量）： Metrics.counter(\u0026#34;fs.sms.all\u0026#34;); Metrics.counter(\u0026#34;fs.sms.aliyun\u0026#34;); Metrics.counter(\u0026#34;fs.sms.huaweiyun\u0026#34;); 正例： Metrics.counter(\u0026#34;fs.sms.send\u0026#34;,\u0026#34;provider\u0026#34;,\u0026#34;ali\u0026#34;); Metrics.counter(\u0026#34;fs.sms.send\u0026#34;,\u0026#34;provider\u0026#34;,\u0026#34;huawei\u0026#34;); 避免无意义不可枚举的 Tag，混乱的 Tag 比无 Tag 更难管理。\n注意事项 注意引入的类名，有很多同名的类，使用 io.micrometer.core 包下的类。 ","date":"August 7, 2023","id":3,"permalink":"/docs/guides/spring-boot-micrometer/","summary":"Spring Boot 使用 Micrometer 集成 Prometheus 监控，5 分钟接入自定义监控指标，主要内容：\nMicrometer 介绍。 业务如何自定义指标，如何接入 Prometheus，实现方式和规范。 Micrometer 介绍 Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标，Micrometer 会负责完成与不同监控系统的适配工作。","tags":"Spring Boot Java","title":"Spring Boot 自定义监控指标"},{"content":"","date":"September 7, 2023","id":4,"permalink":"/docs/guides/","summary":"","tags":"","title":"Guides"},{"content":"","date":"September 7, 2023","id":5,"permalink":"/docs/reference/","summary":"","tags":"","title":"Reference"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"September 7, 2023","id":6,"permalink":"/docs/reference/example/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.","tags":"","title":"Example Reference"},{"content":"","date":"September 7, 2023","id":7,"permalink":"/docs/","summary":"","tags":"","title":"Docs"},{"content":"","date":"September 7, 2023","id":8,"permalink":"/privacy/","summary":"","tags":"","title":"Privacy Policy"},{"content":"","date":"September 7, 2023","id":9,"permalink":"/","summary":"","tags":"","title":"卫星实验室"},{"content":"","date":"August 7, 2023","id":10,"permalink":"/categories/","summary":"","tags":"","title":"Categories"},{"content":"","date":"August 7, 2023","id":11,"permalink":"/tags/java/","summary":"","tags":"","title":"Java"},{"content":"","date":"August 7, 2023","id":12,"permalink":"/categories/java/","summary":"","tags":"","title":"Java"},{"content":"","date":"August 7, 2023","id":13,"permalink":"/tags/spring-boot/","summary":"","tags":"","title":"Spring Boot"},{"content":"","date":"August 7, 2023","id":14,"permalink":"/categories/spring-boot/","summary":"","tags":"","title":"Spring Boot"},{"content":"","date":"August 7, 2023","id":15,"permalink":"/tags/","summary":"","tags":"","title":"Tags"},{"content":"","date":"January 1, 0001","id":16,"permalink":"/contributors/","summary":"","tags":"","title":"Contributors"}]