<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>卫星实验室 on XLabs</title><link>https://www.xlabs.club/</link><description>Recent content in 卫星实验室 on XLabs</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright (c) 2020-2024 XLabs Club</copyright><lastBuildDate>Thu, 11 Apr 2024 17:23:19 +0800</lastBuildDate><atom:link href="https://www.xlabs.club/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://www.xlabs.club/docs/cloud/introduction/</link><pubDate>Thu, 07 Sep 2023 16:04:48 +0200</pubDate><guid>https://www.xlabs.club/docs/cloud/introduction/</guid><description>云原生技术探索。</description></item><item><title>Introduction</title><link>https://www.xlabs.club/docs/guides/introduction/</link><pubDate>Thu, 07 Sep 2023 16:04:48 +0200</pubDate><guid>https://www.xlabs.club/docs/guides/introduction/</guid><description>卫星实验室，一个专注于研究 CRM（Customer Relationship Management，客户关系管理） 的开源组织。
此项目为卫星实验室主页 xlabs.club 的源码，在这里我们将分享 CRM 领域独有的建设经验，介绍如何以技术驱动 CRM 长期发展和高速增长。
加入我们，与我们共同共同探索 CRM 技术前沿，解决行业中的挑战。
主页内容 平台工程：我们的平台工程建设之路，关于 DevOps, DataOps, FinOps 以及 AIOps 的工程实践。 云原生：云原生技术探索，如何以云原生技术支撑起不断变化的复杂业务。 技术博客：研发踩坑记录，翻一翻总有惊喜。 awesome-x-ops：一些关于 AIOps、DataOps、DevOps、GitOps、FinOps 的优秀软件、博客、配套工具。 xlabs-ops：一些运维脚本和模板，如 Argo Workflows 模板仓库，是对官方 Examples 的组合、扩展。 License 本文档采用 CC BY-NC 4.0 许可协议。</description></item><item><title>Kubernetes</title><link>https://www.xlabs.club/docs/tldr/kubernetes/</link><pubDate>Thu, 07 Sep 2023 16:04:48 +0200</pubDate><guid>https://www.xlabs.club/docs/tldr/kubernetes/</guid><description>常用 Kubernetes 命令，复制，粘贴，这就是生活。
复制 secret 到另一个 namespace。 kubectl get secret mys --namespace=na -oyaml | grep -v &amp;#39;^\s*namespace:\s&amp;#39; | kubectl apply --namespace=nb -f -批量删除 pod。 kubectl get pods --all-namespaces | grep Evicted | awk &amp;#39;{print $2 &amp;#34; --namespace=&amp;#34; $1}&amp;#39; | xargs kubectl delete pod # Delete by label kubectl delete pod -n idaas-book -l app.kubernetes.io/name=idaas-book原地重启 Pod。 kubectl rollout restart deploy/xxx -n your-namespace命令行快速扩缩容。 # kubectl scale -h kubectl scale --replicas=1 deploy/xxx -n your-namespace密钥解密。 kubectl get secret my-creds -n mysql -o jsonpath=&amp;#34;{.</description></item><item><title>总体架构</title><link>https://www.xlabs.club/docs/platform/introduction/</link><pubDate>Thu, 07 Sep 2023 16:04:48 +0200</pubDate><guid>https://www.xlabs.club/docs/platform/introduction/</guid><description>我们的平台工程建设之路，介绍前期方案设计、中间踩坑历程。
原则 分享我们平台工程建设的一些基本原则。
以开发者为中心：赋能开发者，了解困难，解决问题，让开发者生活更轻松。 自动化：自动化手动和重复性任务，减少人为错误，提高效率。 标准化：标准化保持一致性，减少复杂性，减少团队认知负载，提供最佳实践和统一的编码结构。 模块化：松耦合且独立的模块，可独立开发、测试和部署。 弹性：可扩展水平扩缩容的能力，以及容错抗脆弱的能力。 安全：相比于微服务、云原生领域的安全，在平台工程里，更强调代码、基础设施、数据和其他资源的安全。 协作：平台工程师、开发人员、运维运营人员以及其他参与者之间的协作，提高生产力、促进创新并创造积极包容的工作环境。 持续改进：持续性反馈、评估、改进。 架构概述 为便于理解，我们仍然按照惯用架构模型，将架构分为 IaaS、CaaS、PaaS、Applications 这几个层级。
专业的运维人员作为 platform engineer 着重于 IaaS、CaaS、PaaS 建设，开发人员作为 application engineer 更专注于 PaaS、Applications 建设，为开发和运维提供工具、协作平台、基础应用。
C4Context title 平台工程总体架构 Boundary(users, "Users", "用户接入") { Person(superAdmin, "超级管理员") Person(admin, "平台管理员") Person(developer, "开发人员") Person(maintenance, "运维人员") } Boundary(console, "Console", "开发者平台") { Container(backstage, "Backstage","react","开发者门户") Container(apps, "应用管理平台","Application","容器管理、应用管理、配置管理、自动化测试") Container(ops, "统一运维平台","x-ops","数据库、中间件、日志、监控告警平台") Container(iam, "IAM", "Keycloak", "统一用户、组织、角色权限管理") } Boundary(paas, "PaaS", "PaaS") { ContainerDb(rds, "RDS", "PostgreSQL/MySQL", "PostgreSQL、MySQL 等关系型数据库") ContainerDb(clickhouse, "ClickHouse", "ClickHouse", "BI、Logging、Metrics 等列式数据库"</description></item><item><title>统一身份认证</title><link>https://www.xlabs.club/docs/platform/iam/</link><pubDate>Tue, 19 Dec 2023 22:26:42 +0800</pubDate><guid>https://www.xlabs.club/docs/platform/iam/</guid><description>统一身份认证（Identity and Access Management，身份认证和访问控制，简称 IAM）的技术选型和实践。
核心需求 集中管理：从一个地方管理账户和身份。 单点登录：允许用户使用一组凭据访问所有集成的系统和应用，避免记忆多个用户名和密码。 动态访问控制：基于角色和策略动态授予或撤销访问权限。 审计与合规：记录和监控访问活动，以支持合规性审计。 无缝快速集成：作为平台工程的一部分更强调“自助”，各个应用能够无缝快速接入，甚至有些应用只需要简单的权限能够不需要开发自动接入。 强化认证机制：采用多因素认证（MFA）等方法，确保只有授权用户才能访问系统和数据。 技术选项 为满足以上需求，在初期技术选项时主要关注以下几个开源组件。
keycloak: 全面的 IAM 解决方案 ，实现用户、权限管理，单点登录、MFA 等。 Dex: 身份代理，连接多个身份源，仅作为 OpenID Connect。 Ory: 包含多个独立的组件，组成一个全家桶的解决方案。 oauth2-proxy: 反向代理工具，专为提供 OAuth 2.0 身份验证和授权服务而设计，附带基于用户、分组、角色的权限管理。 Pomerium: Pomerium 不仅仅是一个 OAuth 2.0 代理，它还提供了细粒度的访问控制，能够根据用户、组、和其他上下文属性来决定访问权限。 以下为 keycloak 和 Dex 的简单对比。为什么不把 Ory 加进来，因为没有实际用过，不便于发表意见，如果你是一个 Ory 用户欢迎补充。
特性/工具 Keycloak Dex 类型 全面的 IAM 解决方案 身份代理 用户管理 支持内置用户管理 不直接管理用户，依赖外部身份提供者 协议支持 OpenID Connect、OAuth 2.0、SAML 2.0 OpenID Connect SSO 支持 依赖外部身份提供者实现 社交登录 支持多种社交登录选项 不直接支持，可通过连接外部身份提供者实现 角色管理 支持复杂的角色和权限管理 不直接支持 扩展性 高，适合各种规模和复杂性的需求 适合将多个身份源统一到一个认证流程的环境 使用场景 需要全面、集中式身份管理的组织 需要统一多个身份源认证，如在云原生环境中 用户界面 提供丰富的用户和管理员界面 主要是 API，没有详细的用户界面 适用性 适用于需要完整 IAM 解决方案的组织 适用于作为多个身份源代理，尤其在 Kubernetes 环境中 以下为 OAuth2 Proxy 和 Pomerium 的简单对比。</description></item><item><title>K8S 服务长连接负载不均衡问题分析和解决办法</title><link>https://www.xlabs.club/blog/tomcat-keepalive-load-balancer/</link><pubDate>Thu, 11 Apr 2024 21:05:46 +0800</pubDate><guid>https://www.xlabs.club/blog/tomcat-keepalive-load-balancer/</guid><description>问题背景，我们有一个 Http 服务在 K8S 内部署了 3 个 Pod，客户端使用 Service NodePort 进行连接，发现流量几乎都集中到了一个 Pod 上。
已知的情况是：
K8S Service 使用 round-robin 负载均衡策略。 客户端和服务端都启用了 Keep-Alive 长连接。 经过抓包分析，负载较高的 Pod 保持着较多 KeepAlive 长连接。将 kube-proxy 的 ipvs 转发模式设置为 Least-Connection，即倾向转发给连接数少的 Pod，可能会有所缓解，但也不一定，因为 ipvs 的负载均衡状态是分散在各个节点的，并没有收敛到一个地方，也就无法在全局层面感知哪个 Pod 上的连接数少，并不能真正做到 Least-Connection。
服务端主动要求断开长连接 客户端连接我们可能无法控制，那么如何从服务端主动断开长连接。
以 Tomcat 为例，它提供了 maxKeepAliveRequests 参数，到达此参数阈值后，Tomcat 会在 Response Header 中主动加一个 Connection: close，正常情况下客户端接收到此响应后会主动断开长连接。
对于其他不支持此参数的服务器，可以自定义 Filter 或者自定代码，到达某阈值后在 Response Header 中主动追加 Connection: close。
对于 Spring Boot 可通过 properties 配置。
# Spring Boot Tomcat server.tomcat.max-keep-alive-requests=100 # Spring Boot WebFlux server.</description></item><item><title>K8S StatefulSet 应用 PV/PVC 平滑扩容</title><link>https://www.xlabs.club/blog/statefulset-resize-pvc/</link><pubDate>Sun, 31 Mar 2024 21:29:52 +0800</pubDate><guid>https://www.xlabs.club/blog/statefulset-resize-pvc/</guid><description>在 K8S 中使用 Helm 部署了一些有状态应用，并通过 Helm 自动生成了 PV 和 PVC，某天想扩容，竟然报错了。
以下以 bitnami zookeeper 为例，其他 StatefulSet 同理。
为了实现磁盘扩容，改大 persistence.size，比如由 8Gi 改为 10Gi，然后执行 helm upgrade，出现错误。
Error: UPGRADE FAILED: cannot patch &amp;#34;zookeeper&amp;#34; with kind StatefulSet: StatefulSet.apps &amp;#34;zookeeper&amp;#34; is invalid: spec: Forbidden: updates to statefulset spec for fields other than &amp;#39;replicas&amp;#39;, &amp;#39;template&amp;#39;, &amp;#39;updateStrategy&amp;#39;, &amp;#39;persistentVolumeClaimRetentionPolicy&amp;#39; and &amp;#39;minReadySeconds&amp;#39; are forbidden 实际上我们想更新的是 StatefulSet 的 spec.volumeClaimTemplates 中的 storage 大小，根据提示信息，StatefulSet 竟然不允许。
spec: volumeClaimTemplates: - apiVersion: v1 spec: resources: requests: storage: 8Gi查看 K8S 官方说明，果然当前版本 (1.</description></item><item><title>MacOS too many open files in system 问题</title><link>https://www.xlabs.club/blog/macos-too-many-open-files/</link><pubDate>Tue, 19 Mar 2024 23:05:07 +0800</pubDate><guid>https://www.xlabs.club/blog/macos-too-many-open-files/</guid><description>作为一个开发， 经常在 MacOS 遇到 Too many open files in system 的报错，尤其是碰到万恶的 node_modules 时，如何固化配置彻底解决，直接上代码。
输入 launchctl limit 即可看到当前的限制，我这里 maxfiles 是改过以后的。
$ launchctl limit cpu unlimited unlimited filesize unlimited unlimited data unlimited unlimited stack 8388608 67104768 core 0 unlimited rss unlimited unlimited memlock unlimited unlimited maxproc 1392 2088 maxfiles 10240 102400 开始创建文件 sudo vi /Library/LaunchDaemons/limit.maxfiles.plist ，内容如下，可根据自己爱好改后面的两个数字值。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;limit.maxfiles&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;string&amp;gt;launchctl&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;limit&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;maxfiles&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;10240&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;102400&amp;lt;/string&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;ServiceIPC&amp;lt;/key&amp;gt; &amp;lt;false/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt;验证文件格式和内容，并应用生效。</description></item><item><title>文件压缩解压缩快速参考</title><link>https://www.xlabs.club/blog/tar-gz/</link><pubDate>Sun, 10 Mar 2024 15:22:20 +0800</pubDate><guid>https://www.xlabs.club/blog/tar-gz/</guid><description>文件压缩解压缩快速参考。
常用文件格式 .tar：tar 其实打包（或翻译为归档）文件，本身并没有压缩。在 Linux 里 man tar 可以看到它的描述也是“manipulate tape archives”（tar 最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案，只是它的描述还没有改）。
.gz：gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。
.bz2：bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。
.Z：compress 也是一个压缩程序。.Z 结尾的文件就是 compress 压缩的结果。
.zip：使用 zip 软件压缩的文件。
.tar.gz、.tar.bz2、.tar.xz 等可以理解为打包+压缩的效果，用软件解压可以发现比。gz 多了一层包。gzip 和 bzip2，不能同时压缩多个文件，tar 相当于开个挂加上同时压缩的特效，tar 先归档为一个大文件，而归档为大文件的速度是很快的，测试了一下几乎可以忽略不计。
除了这些格式外，常见的 deb、exe、msi、rpm、dmg、iso 等安装软件，其实都是经过压缩的，一般情况下没有必要再压缩。而 rar 基本认为是 Windows 平台专属的压缩算法了，各个 Linux 发行版都不自带 rar 压缩解压缩软件，所以可以看到很多软件发行的格式都是 .tar.gz 或 .zip。
解压缩 根据文件名后缀自行选择解压缩命令。
tar -xf test.tar gzip -d test.gz gunzip test.gz # -C 直接解压到指定目录 tar -xzf test.tar.gz -C /home bzip2 -d test.</description></item><item><title>MySQL 大文件导入优化</title><link>https://www.xlabs.club/blog/mysql-large-import/</link><pubDate>Sun, 10 Mar 2024 15:18:22 +0800</pubDate><guid>https://www.xlabs.club/blog/mysql-large-import/</guid><description>项目中需要根据 SQL 文件导入数据，文件大约 20G，正常导入约需要 2 小时，如何加快导入速度。
如果一个 SQL 文件只有一个表的数据，可以直接使用 mysql load data infile 语法，速度比较快。
我们是一个 SQL 文件包含了很多表，导入过程经过如下设置，20G 大约需要 40 分钟，比之前快了很多。
# 进入 mysql mysql -u root -p # 创建数据库（如果已经有数据库忽略此步骤） CREATE DATABASE 数据库名； # 设置参数 set sql_log_bin=OFF;//关闭日志 set autocommit=0;//关闭 autocommit 自动提交模式 0 是关闭 1 是开启（默认） set global max_allowed_packet = 20 *1024* 1024 * 1024; # 使用数据库 use 数据库名； # 开启事务 START TRANSACTION; # 导入 SQL 文件并 COMMIT（因为导入比较耗时，导入和 COMMIT 一行命令） source 文件的路径；COMMIT;</description></item></channel></rss>